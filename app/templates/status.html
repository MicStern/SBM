<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Status</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
    .logs { font-family: monospace; font-size: 12px; white-space: pre-wrap; max-height: 260px; overflow: auto; }
    .row { display:flex; gap:8px; align-items:end; flex-wrap: wrap; }
    label { font-size: 12px; display:block; }
    input { padding: 6px; }
    button { padding: 8px 10px; cursor: pointer; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align:left; }
    .small { font-size: 12px; color: #666; }
  </style>
</head>

<body>
  <h1>Status</h1>
  <p class="small">Theta timezone: <b>{{ theta_timezone }}</b></p>

  <div class="grid">
    <div>
      <div class="card">
        <h2>Runtime</h2>
        <ul>
          <li>Fetcher Started: {{ fetch.started_at|ts_berlin }}</li>
          <li>Fetch Cursor (Berlin): {{ fetch.cursor_utc|ts_berlin }}</li>
          <li>Last Fetch: {{ s.last_fetch_at | ts_berlin }}</li>
          <li>Last Save: {{ s.last_save_at | ts_berlin }}</li>
          <li>Fetched Total: {{ s.fetched_total }}</li>
          <li>Saved Total: {{ s.saved_total }}</li>
          <li>Fetch Errors: {{ s.fetch_errors }}</li>
          <li>Save Errors: {{ s.save_errors }}</li>
          <li>Queue Size: {{ queue_size }}</li>
        </ul>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Continuous Fetch</h2>
        <form method="post" action="/fetch/start">
          <div class="row">
            <div>
              <label>Start (Berlin local)</label>
              <input type="datetime-local" name="start_dt" required>
            </div>
            <div>
              <label>Window (sec)</label>
              <input type="number" name="window_sec" value="{{ fetch.window_sec }}" min="1">
            </div>
            <div>
              <label>Poll (sec)</label>
              <input type="number" name="poll_sec" value="{{ fetch.poll_sec }}" min="1">
            </div>
            <div>
              <button type="submit">Start</button>
            </div>
          </div>
        </form>

        <form method="post" action="/fetch/stop" style="margin-top:8px;">
          <button type="submit">Stop</button>
        </form>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Fetch Once (von/bis)</h2>
        <p class="small">
          Dieser Fetch nutzt exakt dieselbe URL-Build-Logik wie der Continuous-Fetch (inkl. %20 Encoding).
          Start/End werden in <b>{{ theta_timezone }}</b> interpretiert.
        </p>
        <form method="post" action="/fetch/once">
          <div class="row">
            <div>
              <label>From (local)</label>
              <input type="datetime-local" name="start_dt" required>
            </div>
            <div>
              <label>To (local)</label>
              <input type="datetime-local" name="end_dt" required>
            </div>
            <div>
              <button type="submit">Fetch Once</button>
            </div>
          </div>
        </form>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Logs</h2>
        <div class="logs">
{% for line in s.error_logs %}
{{ line }}
{% endfor %}
        </div>
      </div>
    </div>

    <div>
      <div class="card">
        <h2>Groups</h2>
        <table>
          <thead>
            <tr>
              <th>Label UID</th>
              <th>Count</th>
              <th>Last Seen</th>
              <th>Label</th>
            </tr>
          </thead>
          <tbody>
            {% for g in groups %}
            <tr>
              <td><a href="#" onclick="loadFrames('{{ g.label_uid }}'); return false;">{{ g.label_uid }}</a></td>
              <td>{{ g.count }}</td>
              <td>{{ g.last_seen|ts_berlin }}</td>
              <td>
                <form method="post" action="/label">
                  <input type="hidden" name="label_uid" value="{{ g.label_uid }}">
                  <input name="label" value="{{ g.label or '' }}" style="width: 180px;">
                  <button type="submit">Save</button>
                </form>
              </td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Weight Visualization</h2>
        <p class="small">Klicke auf eine Group (links), um Frames zu laden.</p>

        <canvas id="canvas" width="420" height="420" style="border:1px solid #ddd; border-radius:8px;"></canvas>

        <div class="row" style="margin-top:10px;">
          <button onclick="togglePlay()">Play/Pause</button>
          <span class="small" id="frameInfo">No data loaded</span>
        </div>
      </div>
    </div>
  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const frameInfo = document.getElementById("frameInfo");

  let frames = [];
  let frameIndex = 0;
  let playing = false;
  let timer = null;

  const positions = {
    a: {x:-1, y:-1},
    b: {x: 1, y:-1},
    c: {x:-1, y: 1},
    d: {x: 1, y: 1},
  };

  const mapping = {
    a: "weight_a",
    b: "weight_b",
    c: "weight_c",
    d: "weight_d",
  };

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  function toNumber(v) { const n = Number(v); return Number.isFinite(n) ? n : 0; }

  function computeCenter(frame) {
    let sumW = 0, sumX = 0, sumY = 0;

    for (const corner of Object.keys(mapping)) {
      const key = mapping[corner];
      const w = Math.abs(toNumber(frame[key]));  // Betrag
      if (w === 0) continue;

      const pos = positions[corner];
      sumW += w;
      sumX += w * pos.x;
      sumY += w * pos.y;
    }

    if (sumW === 0) return {x:0, y:0};
    return { x: clamp(sumX / sumW, -1, 1), y: clamp(sumY / sumW, -1, 1) };
  }

  function draw(frame) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // border box
    ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);

    const c = computeCenter(frame);

    const cx = (canvas.width / 2) + c.x * (canvas.width / 2 - 40);
    const cy = (canvas.height / 2) + c.y * (canvas.height / 2 - 40);

    // draw dot
    ctx.beginPath();
    ctx.arc(cx, cy, 8, 0, Math.PI * 2);
    ctx.fill();

    const ts = frame.timestamp_sensor_iso || frame.timestamp || "";
    frameInfo.textContent = `Frame ${frameIndex+1}/${frames.length}  ${ts}`;
  }

  function step() {
    if (!frames.length) return;
    draw(frames[frameIndex]);
    frameIndex = (frameIndex + 1) % frames.length;
  }

  function togglePlay() {
    playing = !playing;
    if (playing) {
      if (timer) clearInterval(timer);
      timer = setInterval(step, 150);
    } else {
      if (timer) clearInterval(timer);
      timer = null;
    }
  }

  async function loadFrames(labelUid) {
    const res = await fetch(`/group_frames?label_uid=${encodeURIComponent(labelUid)}`);
    const data = await res.json();
    frames = data.frames || [];
    frameIndex = 0;

    if (frames.length) {
      draw(frames[0]);
    } else {
      frameInfo.textContent = "No frames returned";
    }
  }
</script>

</body>
</html>
