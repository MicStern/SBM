<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Status</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 16px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
    .logs { font-family: monospace; font-size: 12px; white-space: pre-wrap; max-height: 260px; overflow: auto; }
    .row { display:flex; gap:8px; align-items:end; flex-wrap: wrap; }
    label { font-size: 12px; display:block; }
    input, select { padding: 6px; }
    button { padding: 8px 10px; cursor: pointer; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align:left; }
    .small { font-size: 12px; color: #666; }
    a { color: #0b57d0; }
  </style>
</head>

<body>
  <h1>Status</h1>
  <p class="small">Theta timezone: <b>{{ theta_timezone }}</b></p>

  <div class="grid">
    <div>
      <div class="card">
        <h2>Runtime</h2>
        <ul>
          <li>Fetcher Started: {{ fetch.started_at|ts_berlin }}</li>
          <li>Fetch Cursor (Berlin): {{ fetch.cursor_utc|ts_berlin }}</li>
          <li>Last Fetch: {{ s.last_fetch_at | ts_berlin }}</li>
          <li>Last Save: {{ s.last_save_at | ts_berlin }}</li>
          <li>Fetched Total: {{ s.fetched_total }}</li>
          <li>Saved Total: {{ s.saved_total }}</li>
          <li>Fetch Errors: {{ s.fetch_errors }}</li>
          <li>Save Errors: {{ s.save_errors }}</li>
          <li>Queue Size: {{ queue_size }}</li>
        </ul>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Continuous Fetch</h2>
        <form method="post" action="/fetch/start">
          <div class="row">
            <div>
              <label>Start (Berlin local)</label>
              <input type="datetime-local" name="start_dt" required>
            </div>
            <div>
              <label>Window (sec)</label>
              <input type="number" name="window_sec" value="{{ fetch.window_sec }}" min="1">
            </div>
            <div>
              <label>Poll (sec)</label>
              <input type="number" name="poll_sec" value="{{ fetch.poll_sec }}" min="1">
            </div>
            <div>
              <button type="submit">Start</button>
            </div>
          </div>
        </form>

        <form method="post" action="/fetch/stop" style="margin-top:8px;">
          <button type="submit">Stop</button>
        </form>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Fetch Once (von/bis)</h2>
        <p class="small">
          Dieser Fetch nutzt exakt dieselbe URL-Build-Logik wie der Continuous-Fetch (inkl. %20 Encoding).
          Start/End werden in <b>{{ theta_timezone }}</b> interpretiert.
        </p>
        <form method="post" action="/fetch/once">
          <div class="row">
            <div>
              <label>From (local)</label>
              <input type="datetime-local" name="start_dt" required>
            </div>
            <div>
              <label>To (local)</label>
              <input type="datetime-local" name="end_dt" required>
            </div>
            <div>
              <button type="submit">Fetch Once</button>
            </div>
          </div>
        </form>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Logs</h2>
        <div class="logs">
{% for line in s.error_logs %}
{{ line }}
{% endfor %}
        </div>
      </div>
    </div>

    <div>
      <div class="card">
        <h2>Groups</h2>
        <table>
          <thead>
            <tr>
              <th>Label UID</th>
              <th>Count</th>
              <th>Last Seen</th>
              <th>Label</th>
            </tr>
          </thead>
          <tbody>
            {% for g in groups %}
            <tr>
              <td><a href="#" onclick="loadFrames('{{ g.label_uid }}'); return false;">{{ g.label_uid }}</a></td>
              <td>{{ g.count }}</td>
              <td>{{ g.last_seen|ts_berlin }}</td>
              <td>
                <form method="post" action="/label">
                  <input type="hidden" name="label_uid" value="{{ g.label_uid }}">
                  <input name="label" value="{{ g.label or '' }}" style="width: 180px;">
                  <button type="submit">Save</button>
                </form>
              </td>
            </tr>
            {% endfor %}
          </tbody>
        </table>
      </div>

      <div class="card" style="margin-top:16px;">
        <h2>Weight Visualization</h2>
        <p class="small">Klicke auf eine Group (links), um Frames zu laden.</p>

        <canvas id="canvas" width="420" height="420" style="border:1px solid #ddd; border-radius:8px;"></canvas>

        <div class="card" style="margin-top:12px;">
          <h3 style="margin:0 0 8px 0;">Foot → Sensor mapping</h3>
          <div class="row">
            <div>
              <label>Top-left</label>
              <select id="map_tl"></select>
            </div>
            <div>
              <label>Top-right</label>
              <select id="map_tr"></select>
            </div>
            <div>
              <label>Bottom-left</label>
              <select id="map_bl"></select>
            </div>
            <div>
              <label>Bottom-right</label>
              <select id="map_br"></select>
            </div>
            <div style="align-self:end;">
              <button onclick="resetMapping()" type="button">Reset</button>
            </div>
          </div>
          <p class="small" style="margin:8px 0 0 0;">
            Mapping is stored locally in your browser (localStorage).
          </p>
        </div>

        <div class="row" style="margin-top:10px;">
          <button onclick="togglePlay()" type="button">Play/Pause</button>
          <span class="small" id="frameInfo">No data loaded</span>
        </div>
      </div>
    </div>
  </div>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const frameInfo = document.getElementById("frameInfo");

  let frames = [];
  let frameIndex = 0;
  let playing = false;
  let timer = null;

  function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
  function toNumber(v) { const n = Number(v); return Number.isFinite(n) ? n : 0; }

  // === Mapping UI ===
  const SENSOR_KEYS = ["weight_a", "weight_b", "weight_c", "weight_d", "none"];
  const STORAGE_KEY = "foot_sensor_mapping_v1";

  // Ecken/füße (tl/tr/bl/br) -> sensor key
  let footMapping = {
    tl: "weight_a",
    tr: "weight_b",
    bl: "weight_c",
    br: "weight_d",
  };

  function loadMapping() {
    try {
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return;
      const obj = JSON.parse(raw);
      for (const k of ["tl","tr","bl","br"]) {
        if (SENSOR_KEYS.includes(obj?.[k])) footMapping[k] = obj[k];
      }
    } catch (_) {}
  }

  function saveMapping() {
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(footMapping));
    } catch (_) {}
  }

  function populateSelect(selectEl, selectedValue) {
    selectEl.innerHTML = "";
    for (const key of SENSOR_KEYS) {
      const opt = document.createElement("option");
      opt.value = key;
      opt.textContent = key;
      if (key === selectedValue) opt.selected = true;
      selectEl.appendChild(opt);
    }
  }

  function wireMappingUI() {
    loadMapping();

    const tl = document.getElementById("map_tl");
    const tr = document.getElementById("map_tr");
    const bl = document.getElementById("map_bl");
    const br = document.getElementById("map_br");

    populateSelect(tl, footMapping.tl);
    populateSelect(tr, footMapping.tr);
    populateSelect(bl, footMapping.bl);
    populateSelect(br, footMapping.br);

    tl.onchange = () => { footMapping.tl = tl.value; saveMapping(); redraw(); };
    tr.onchange = () => { footMapping.tr = tr.value; saveMapping(); redraw(); };
    bl.onchange = () => { footMapping.bl = bl.value; saveMapping(); redraw(); };
    br.onchange = () => { footMapping.br = br.value; saveMapping(); redraw(); };
  }

  function resetMapping() {
    footMapping = { tl:"weight_a", tr:"weight_b", bl:"weight_c", br:"weight_d" };
    saveMapping();
    wireMappingUI();
    redraw();
  }

  // === Visualizer ===
  function computeCenter(frame) {
    let sumW = 0, sumX = 0, sumY = 0;

    const corners = [
      { id: "tl", pos: { x: -1, y: -1 } },
      { id: "tr", pos: { x:  1, y: -1 } },
      { id: "bl", pos: { x: -1, y:  1 } },
      { id: "br", pos: { x:  1, y:  1 } },
    ];

    for (const c of corners) {
      const key = footMapping[c.id];
      if (!key || key === "none") continue;

      const w = Math.abs(toNumber(frame[key])); // Betrag
      if (w === 0) continue;

      sumW += w;
      sumX += w * c.pos.x;
      sumY += w * c.pos.y;
    }

    if (sumW === 0) return { x: 0, y: 0 };
    return { x: clamp(sumX / sumW, -1, 1), y: clamp(sumY / sumW, -1, 1) };
  }

  function draw(frame) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // border box
    ctx.strokeRect(20, 20, canvas.width - 40, canvas.height - 40);

    const c = computeCenter(frame);

    const cx = (canvas.width / 2) + c.x * (canvas.width / 2 - 40);
    const cy = (canvas.height / 2) + c.y * (canvas.height / 2 - 40);

    // draw dot
    ctx.beginPath();
    ctx.arc(cx, cy, 8, 0, Math.PI * 2);
    ctx.fill();

    const ts = frame.timestamp_sensor_iso || frame.timestamp || "";
    frameInfo.textContent = `Frame ${frameIndex+1}/${frames.length}  ${ts}`;
  }

  function redraw() {
    if (!frames.length) return;
    const idx = Math.min(frameIndex, frames.length - 1);
    draw(frames[idx]);
  }

  function step() {
    if (!frames.length) return;
    draw(frames[frameIndex]);
    frameIndex = (frameIndex + 1) % frames.length;
  }

  function togglePlay() {
    playing = !playing;
    if (playing) {
      if (timer) clearInterval(timer);
      timer = setInterval(step, 150);
    } else {
      if (timer) clearInterval(timer);
      timer = null;
    }
  }

  async function loadFrames(labelUid) {
    const res = await fetch(`/group_frames?label_uid=${encodeURIComponent(labelUid)}`);
    const data = await res.json();
    frames = data.frames || [];
    frameIndex = 0;

    if (frames.length) {
      draw(frames[0]);
    } else {
      frameInfo.textContent = "No frames returned";
    }
  }

  // init mapping UI on page load
  wireMappingUI();
</script>

</body>
</html>
